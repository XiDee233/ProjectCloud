## 实现SceneQuadtreeManager的多玩家支持

### 1. 核心需求
- SceneQuadtreeManager支持多个PlayerSceneTracker
- 考虑所有玩家位置进行场景管理
- 适配Host和Client模式

### 2. 实现步骤

#### 2.1 修改SceneQuadtreeManager
1. 将单一`_playerTracker`字段改为`List<PlayerSceneTracker>`类型
2. 添加`RegisterTracker`和`UnregisterTracker`方法
3. 更新场景管理逻辑，考虑所有注册的PlayerSceneTracker

#### 2.2 更新PlayerSceneTracker
1. 在`OnEnable`中自动注册到SceneQuadtreeManager
2. 在`OnDisable`中自动注销
3. 保持现有事件机制

#### 2.3 实现多玩家场景逻辑
1. 收集所有玩家位置
2. 计算场景加载/卸载需求
3. 执行场景操作

### 3. 具体代码实现

#### 3.1 SceneQuadtreeManager修改
```csharp
// 将单一引用改为列表
private List<PlayerSceneTracker> _playerTrackers = new List<PlayerSceneTracker>();

// 移除旧的单一引用字段
// [SerializeField] private PlayerSceneTracker _playerTracker;

// 添加注册/注销方法
public void RegisterTracker(PlayerSceneTracker tracker)
{
    _playerTrackers.Add(tracker);
    tracker.onPlayerMoved += OnPlayerMoved;
}

public void UnregisterTracker(PlayerSceneTracker tracker)
{
    if (_playerTrackers.Remove(tracker))
    {
        tracker.onPlayerMoved -= OnPlayerMoved;
    }
}

// 更新Start方法，移除旧代码
private void Start()
{
    // 移除旧的_playerTracker事件订阅
}

// 保持OnPlayerMoved方法不变，它会处理所有玩家的移动事件
```

#### 3.2 PlayerSceneTracker修改
```csharp
private void OnEnable()
{
    // 自动注册到SceneQuadtreeManager
    SceneQuadtreeManager manager = FindObjectOfType<SceneQuadtreeManager>();
    if (manager != null)
    {
        manager.RegisterTracker(this);
    }
}

private void OnDisable()
{
    // 自动从SceneQuadtreeManager注销
    SceneQuadtreeManager manager = FindObjectOfType<SceneQuadtreeManager>();
    if (manager != null)
    {
        manager.UnregisterTracker(this);
    }
}
```

### 4. 预期效果
- 每个PlayerSceneTracker自动注册到SceneQuadtreeManager
- SceneQuadtreeManager处理所有玩家的移动事件
- 根据所有玩家位置计算场景加载/卸载
- 支持任意数量的玩家
- 适配Host和Client模式

### 5. 关键优势
- 简单直接：修改最少，功能完整
- 自动管理：PlayerSceneTracker自动注册/注销
- 多玩家支持：处理任意数量的玩家
- 网络兼容：适配Host和Client模式
- 保持现有架构：不破坏现有代码结构

### 6. 修改文件
- `SceneQuadtreeManager.cs`：支持多PlayerSceneTracker
- `PlayerSceneTracker.cs`：自动注册/注销机制

这个实现简单直接，完全解决了SceneQuadtreeManager支持多个玩家的问题，不添加任何多余功能。